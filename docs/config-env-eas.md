üìÑ Config + Env + EAS Build Notes (Why dotenv-cli fixed it)
Problem we hit

EAS Build / EAS Update failed with errors like:

Missing env: EXPO_PUBLIC_API_BASE_URL (DOTENV_FILE=.env.uat)

Missing config: expo.extra.app.apiBaseURL

CI builds ‚Äúworked locally‚Äù but failed in GitHub Actions / EAS.

Root symptom from logs:

[dotenv] injecting env (0) from .env.uat

This means dotenv found the file but loaded zero variables.

Could be formatting/hidden chars, wrong file getting read, or env not inherited into the subprocess EAS uses (npx expo config).

Why dotenv-cli fixed it
What EAS actually does

When you run eas build, EAS often evaluates your Expo config by running something like:

npx expo config --json (internally)

which executes app.config.js / app.config.ts

which expects env vars to exist (either already in process.env, or loaded from a .env file)

Why relying on DOTENV_FILE alone is fragile

Even if you do:

EXPO_NO_DOTENV=1 DOTENV_FILE=.env.uat eas build ...


it can still fail because:

EAS may spawn subprocesses in a way where env vars aren‚Äôt inherited as expected in some contexts

dotenv.config({ path: process.env.DOTENV_FILE }) may load 0 vars if the file has:

leading spaces / indentation (common if generated by heredoc with indentation)

CRLF/BOM or hidden characters

invalid formatting (invisible but real)

remote EAS builders may not include .env.* files depending on ignore rules / packaging behavior

What dotenv-cli changes

With dotenv-cli:

dotenv -e .env.uat -- eas build ...


dotenv-cli loads the file in the current shell and exports all variables into process.env before EAS runs.

So EAS doesn‚Äôt need to successfully read the file later ‚Äî it just sees the env values already set.

‚úÖ This is why dotenv-cli made yarn build:prod:android succeed.

Our recommended ‚Äúenterprise-stable‚Äù pattern
1) Use Expo extra.app for runtime config

We keep runtime config in expo.extra.app.* so it works in:

Expo Go / dev

EAS Update (OTA)

EAS Build binaries

Example runtime reads:

Constants.expoConfig?.extra?.app

fallback to Updates manifest extras in production

2) Inject env before running Expo/EAS commands (dotenv-cli)

Local scripts:

{
  "scripts": {
    "update:prod": "dotenv -e .env.prod -- eas update --branch production --platform all",
    "build:prod:android": "dotenv -e .env.prod -- eas build --profile production --platform android",
    "build:uat:android": "dotenv -e .env.uat -- eas build --profile uat --platform android"
  }
}


This makes builds consistent and avoids ‚ÄúDOTENV_FILE not respected‚Äù surprises.

3) Keep app.config.js defensive

app.config.js should:

prefer reading from process.env

only load a file via dotenv as a fallback (optional)

throw clear errors if required vars are missing

Debugging commands we used
Verify Expo config outputs expected extra.app
EXPO_NO_DOTENV=1 DOTENV_FILE=.env.uat npx expo config --type public

Verify bundling works with config
EXPO_NO_DOTENV=1 DOTENV_FILE=.env.uat npx expo export --platform android --output-dir /tmp/dist

Verify dotenv can parse your env file
node -e "require('dotenv').config({ path: '.env.uat' }); console.log(process.env.EXPO_PUBLIC_API_BASE_URL)"

Detect hidden characters / indentation issues
cat -A .env.uat

CI / GitHub Actions guidance

In CI, we should not depend on .env.* existing unless we intentionally create them.

Preferred approach:

create .env.ci during the workflow (dummy safe values)

or inject env vars directly using env: in steps

and run a preflight expo config + expo export before EAS build

Key takeaways

‚úÖ dotenv-cli fixed the issue because it injects env vars early, so EAS doesn‚Äôt need to parse .env.* later.

‚úÖ Relying only on DOTENV_FILE is fragile in CI/EAS because subprocesses and file parsing can fail in subtle ways.

‚úÖ The stable setup is:

app.config.js builds extra.app

runtime reads from Constants/Updates extra

scripts use dotenv -e <file> -- ... for EAS build/update

CI preflight ensures config is correct before consuming EAS build minutes


---

# Env + EAS Build Notes (SHK)

## Problem we hit
Remote EAS builds sometimes failed with:

- `Missing env: EXPO_PUBLIC_API_BASE_URL (DOTENV_FILE=.env.uat)`
- or the build used `env: local` even when profile was `uat/production`.

Root cause:
- `.env.uat` is available locally, but **not guaranteed** to be present inside the remote EAS builder.
- Relying on reading `.env.*` files inside `app.config.js` causes remote builds to fall back to `.env`/`local` or fail.

## Golden rule
‚úÖ Remote EAS build should get env vars via:
1) `eas.json -> build.<profile>.env` (for non-secret values), OR
2) Expo dashboard EAS Environment Variables (for secrets)

üö´ Do not rely on shipping `.env.*` files to remote EAS builders.

## app.config.js behavior
- Determine environment from `EAS_BUILD_PROFILE` first (remote builds).
- Load dotenv file only if needed *and* file exists.
- Never silently fall back to `.env`.

## Local builds
We use dotenv-cli:

- UAT:
  `yarn build:uat:android`
- PROD:
  `yarn build:prod:android`

## GitHub Actions PR builds
- `pr-preflight.yml` runs always on PR open/sync.
- `pr-eas-build-android.yml` runs only when PR has labels:
  - `ci:eas-build` (uat)
  - `ci:eas-build-prod` (production)

Reusable workflow path must match exactly:
`./.github/workflows/pr-eas-build-android.yml`
(no typos like "andriod").
